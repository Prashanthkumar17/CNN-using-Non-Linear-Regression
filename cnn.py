# -*- coding: utf-8 -*-
"""CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HRDV3Qr_yb-s3VWKEaMwcTDHe5weiPo_
"""

# Commented out IPython magic to ensure Python compatibility.
from sklearn import linear_model
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error,r2_score
import pandas as pd
import numpy as np
import plotly.express as plt
import matplotlib.pyplot as plt
# %matplotlib inline
#reading the dataset
dataset = pd.read_csv('/content/housing.csv')
print("Here are the first five rows of the dataset:")
dataset = dataset.dropna()
Y = dataset['median_house_value']
X = dataset.loc[:,'longitude' : 'median_income']
#dataset.head()
dataset.head(10)

plt.style.use('ggplot')
dataset.plot(subplots=True)
#plt.tight_layout()
plt.show()

Y = dataset['median_house_value']
X = dataset.loc[:,'longitude' : 'median_income']

x_train,x_test,y_train,y_test=train_test_split(X,Y,test_size=0.3)
x_train_np=x_train.to_numpy()
x_test_np=x_test.to_numpy()
y_train_np=y_train.to_numpy()
y_test_np=y_test.to_numpy()

import torch
from torch.nn import Conv1d
from torch.nn import MaxPool1d
from torch.nn import Flatten
from torch.nn import Linear
from torch.nn.functional import relu
from torch.utils.data import DataLoader, TensorDataset

class CnnRegressor(torch.nn.Module):
  def __init__(self, batch_size, inputs, outputs):
    super(CnnRegressor,self).__init__()
    self.batch_size=batch_size
    self.inputs=inputs
    self.outputs=outputs
    self.input_layer=Conv1d(inputs,batch_size,1)
    self.max_pooling_layer=MaxPool1d(1)
    self.conv_layer=Conv1d(batch_size,64,1)
    self.flatten_layer=Flatten()
    self.linear_layer=Linear(64,32)
    self.output_layer=Linear(32,outputs)

  def feed(self,input):

    input=input.reshape((self.batch_size,self.inputs,1))

    output=relu(self.input_layer(input))

    output=self.max_pooling_layer(output)

    output=relu(self.conv_layer(output))
    output=self.flatten_layer(output)
    output=self.linear_layer(output)
    output=self.output_layer(output)
    return output

from torch.optim import SGD
from torch.nn import  L1Loss

!pip install pytorch-ignite
from ignite.contrib.metrics.regression.r2_score import R2Score

batch_size=128
model = CnnRegressor(batch_size, X.shape[1],1)
model.cuda()

def model_loss(model, dataset, train =False, optimizer = None):

  performance = L1Loss()
  score_metric = R2Score()

  avg_loss = 0
  avg_score = 0
  count = 0
  for input , output in iter(dataset):
    predictions = model.feed(input)
    loss = performance(predictions, output)
    score_metric.update([predictions, output])
    score = score_metric.compute ()
    if(train):
      optimizer.zero_grad()
      loss.backward()
      optimizer.step()
    
    avg_loss += loss.item()
    avg_score += score
    count +=1
  
  return avg_loss/count, avg_score/count

epochs = 300
optimizer=torch.optim.RMSprop(model.parameters(),lr=1e-3)

inputs=torch.from_numpy(x_train_np).cuda().float()
outputs=torch.from_numpy(y_train_np.reshape(y_train_np.shape[0],1)).cuda().float()

tensor = TensorDataset(inputs,outputs)
loader = DataLoader(tensor,batch_size, shuffle=True, drop_last=True)

for epoch in range(epochs):
  avg_loss, avg_r2_score = model_loss(model,loader,train=True, optimizer=optimizer)
  print("Epoch" +str(epoch+1)+ ":\n\tLoss = "+ str(avg_loss)+"\n\tR^2 SCore = " +str(avg_r2_score))

inputs = torch.from_numpy(x_test_np).cuda().float()

outputs = torch.from_numpy(y_test_np.reshape(y_test_np.shape[0], 1)).cuda().float()

tensor = TensorDataset(inputs, outputs)

loader = DataLoader(tensor, batch_size, shuffle=True, drop_last=True)

avg_loss, avg_r2_score = model_loss(model, loader)

print("The model's L1 loss is: " + str(avg_loss))

print("The model's R^2 score is: " + str(avg_r2_score))

torch.save(model,"/content/1116540_1dconv_reg.pthg")

"""# New Section"""